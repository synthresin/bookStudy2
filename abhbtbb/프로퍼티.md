## 프로퍼티

프로퍼티는 이름과 값으로 구성된다.
프로퍼티 이름은 빈 문자열을 포함한 어떤 문자열이든 될 수 있다.
객체가 같은 이름의 프로퍼티를 두개 가질 수는 없다.
프로퍼티 값은 자바스크립트의 어떠한 값이든 될수 있고, ES5에서는 getter, setter 함수도 될 수 있다.
프로퍼티의 이름과 값 외에, 객체의 각 프로퍼티는 프로퍼티 속성( property attribute ) 라는 연관된 값을 갖는다.

- 쓰기( writable ) 속성은 프로퍼티 값의 수정 가능 여부를 결정한다.
- 열거( enumerable ) 속성은 프로퍼티의 이름을 for/in 루프에서 읽을 수 있는지 여부를 결정한다.
- 설정( configurable ) 속성은 프로퍼티의 삭제 가능 여부와 프로퍼티 속성의 변경 가능 여부를 결정한다.

ES5 이전에는 코드에서 생성한 객체의 프로퍼티는 전부 수정하거나 열거할수 있고, 설정할 수 잇었다.
ES5 부터는 작성자가 만든 프로퍼티의 속성만을 변경할 수 있다.

프로퍼티를 포함한 모든 객체는 세 가지의 속성 ( object attribute )를 갖는다.

- prototype은 상속받은 프로퍼티들을 가진 객체를 참조한다.
- class는 객체의 자료형( 타입 )을 특정짓는 문자열이다.
- extensible 속성( ES5 )은 객체에 새 프로퍼티를 추가할 수 있는지를 결정한다.



#### 네이티브 객체( native object )

ECMAScript 명세에 정의된 객체 또는 그 객체의 클래스이다. Array, Function, Date, 정규표현식들은 전부 네이티브 객체이다.

#### 호스트 객체( host object )

브라우저와 같이 자바스크립트 인터프리터가 내장된 호스트 환경에 정의된 객체이다. HTMLElement 객체는 웹 페이지의 구조가 클라이언트 측 자바스크립트로 표현된 호스트 객체이다. 호스트 환경에서 메서드들을 정의할 때 일반적으로 자바스크립트 Function 객체로 정의하는 것과 마찬가지로, 호스트 객체는 네이티브 객체일 수도 있다.

#### 사용자 정의 객체( user-defined object )

자바스크립트 코드의 실행으로 생성된 객체이다.

#### 고유 프로퍼티( own property )

객체에 직접 정의된 프로퍼티이다.

#### 상속받은 프로퍼티( inherited property )

객체의 프로토타입 객체가 정의한 프로퍼티를 말한다.



## new를 사용해 객체 생성하기

new 연산자는 객체를 만들고 초기화한다. new 키워드 다음에는 반드시 함수 호출문이 와야 하는데 이 호출되는 함수를 생성자( constructor ) 라고 한다. 이것은 새로 생성된 객체를 초기화 하는 역할을 한다. 코어 자바스크립트는 기본 타입에 대한 생성자를 내장하고 있다. 

```javascript
var o = new Object();
var a = new Array();
var d = new Date();
var r = new RegExp("js");
```

또한 미리 작성된 생성자뿐 아니라, 원하는 형태의 객체를 생성하고 초기화하기 위해 임의의 생성자 함수를 직접 정의할 수도 있다.



## 프로토타입

new를 이용해서 객체가 생성될때, 프로토타입 ( prototype )이라는 객체로부터 프로퍼티들을 상속받는다.
new 키워드를 사용해 생성자를 호출하면, 생성자 함수의 프로토타입이 생성된 객체의 프로토타입이 된다.
Object.prototype은 프로토타입이 없는 매우 드문 객체 중 하나이다. 아무런 프로퍼티도 상속받지 않는다. 하지만 다른 프로토타입 객체들은 보통 프로토타입을 갖는다.
모든 내장 생성자는 Object.prototype을 상속하는 객체를 프로토타입으로 갖는다. 
즉, new Date()를 통해 생성한 Date 객체는 Date.prototype, Object.prototype으로부터 프로퍼티를 상속받는다.
이처럼 프로토타입 객체들이 연결된 것을 프로토타입 체인이라고 한다.



### Object.create()

ES5는 객체를 생성하는 Object.create() 메서드를 지원한다.
이 메서드의 첫번째 인자가 프로토타입 객체이다.
Object.create()는 새 객체의 프로퍼티 정보를 두 번째 인자로 받을 수 있는데 생략가능하다.
이 메소드는 정적 함수이며, 개별 객체를 통해 호출되는 메서드가 아니다. 함수를 사용하기 위해서는 단순히 프로토타입 객체를 넘기기만 하면 된다.

```javascript
var o1 = Object.create({x:1, y:2}); // o1은 x, y 프로퍼티를 상속받는다.
```

프로토타입을 갖지 않는 새 객체를 만들기 위해서는 함수에 null을 전달하면 되지만, 이 경우에는 새롭게 생성된 객체가 어떠한 객체도 상속받지 않기 때문에 toString() 과 같은 기본적인 메서드조차 사용할수 없으며 연산자 + 도 사용불가하다.

만약 일반적인 객체 ```new Object() ``` 를 만들고 싶다면 ```Object.prototype``` 을 전달한다.

```javascript
var o3 = Object.create( Object.prototype );		// o3는 {} 또는 new Object() 와 같은 객체
```

Object.create()는 임의의 프로토타입으로 새 객체를 만들수 있다는 점 ( 특정 객체를 상속받는 상속자 객체를 만들수 있다는 것) 에서 유용하며 ES3에서는 아래와 같이 구현 가능하다.

```javascript
/* inherit()은 프로토타입 객체 p의 속성을 상속받아 새롭게 생성된 객체를 반환한다.
 * 만일 ES5함수인 Object.create() 가 정의되어 있다면 해당 함수를 사용가능하다.
 * 사용할수 없는 경우에는 예전 방법을 사용한다.
 */
function inherit( p ) {
  if( p == null ) throw TypeError();		// p는 null이 아닌 객체여야 한다.
  if( Object.create )						// 만약 Object.create 사용 가능시, 이를 사용한다.
    return Object.create( p );
  
  var t = typeof p;							// 객체 타입 검사가 더 필요한 경우에 이렇게 한다.
  if( t !== "object" && t !== "function") throw TypeError();
  
  function f() {};							// 임시로 빈 생성자 함수를 정의한다.
  f.prototype = p;							// f의 프로토 타입 프로퍼티를 p로 설정
  return new f();							// 함수 f()를 사용한다.
}
```

inherit 를 이용하면 임의의 라이브러리 함수에 의해 뜻하지 않게 수정되는 것을 막을 수 있다. 함수에 객체를 직접 전달하는 대신, 해당 객체의 프로퍼티를 상속한 객체를 전달하는 것이다. 함수가 프로퍼티를 읽는 다면, 상속받은 값을 보게되며 만약 함수가 프로퍼티를 설정한다면, 이는 기존의 객체가 아닌 새로 만들어진 객체에만 영향을 미친다.